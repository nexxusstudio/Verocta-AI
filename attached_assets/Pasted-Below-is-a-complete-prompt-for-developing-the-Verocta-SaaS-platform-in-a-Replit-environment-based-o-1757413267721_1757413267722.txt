Below is a complete prompt for developing the Verocta SaaS platform in a Replit environment, based on the provided project report and requirements. This prompt is tailored to deliver a fully functional, launch-ready system with all specified features, optimized for clarity and execution within Replit’s constraints.

---

**Complete Prompt for Verocta Development**

```
Please develop a complete, self-contained software project for a Replit environment.

**Project Name:** Verocta
**Project Goal:** Build a SaaS platform for financial spend analysis, delivering SpendScore™, waste %, duplicates, spikes, category breakdowns, forecasting, benchmarking, and gamification. Includes CSV/Google Sheets ingestion, JWT authentication, reports, automated emails, Stripe monetization, and deployment-ready infrastructure.
**Target User:** SMBs and mid-market companies optimizing financial spend.

**Technology Stack:**
- **Backend Language:** Python
- **Backend Framework:** Flask
- **Frontend Language:** HTML, CSS, JavaScript (React for frontend, provided by client)
- **Database:** SQLite (for Replit/dev), scalable to PostgreSQL (production)
- **Styling:** Tailwind CSS
- **API:** REST API with JSON payloads
- **External Libraries:** flask-jwt-extended, pandas, gspread, stripe, python-dotenv, reportlab (PDFs), smtplib/SendGrid

**Features to Implement:**
1. **Authentication:**
   - JWT-based login/signup (email, bcrypt password).
   - Refresh tokens, 15m access/7d refresh expiry.
   - Role-based access (Admin/User).
   - Audit logs for login/logout/failed attempts.
2. **Admin Dashboard (API-driven):**
   - View all reports, system-wide SpendScore summaries.
   - CSV mapping UI (column selection).
   - User management (roles, subscriptions, metrics).
   - Account settings (billing, invoices).
3. **Reports Module:**
   - APIs: GET /api/reports (list), GET /api/reports/{id} (view), GET /api/reports/{id}/download (PDF), DELETE /api/reports/{id} (soft delete).
   - Store report metadata in DB, PDFs in filesystem (for Replit).
4. **Data Ingestion:**
   - CSV upload with frontend validation (.csv only), manual column mapping (Date, Amount, Category).
   - Google Sheets integration via gspread (OAuth/service account).
   - Pandas-based normalization pipeline, error logging for invalid files.
5. **Automated Emails:**
   - Triggers: Welcome (signup), report delivery (PDF + metrics), monthly reminders.
   - Use smtplib (Gmail SMTP) or SendGrid, HTML/Jinja templates, log delivery status.
6. **Insights Engine:**
   - SpendScore™ (0-100, RAG thresholds), waste % (essential vs non-essential), duplicate subscriptions (vendor clustering), spend spikes (IQR), category breakdown/diversity.
   - Extended: Forecasting (basic time series), benchmarking (mock averages), gamification (rewards for SpendScore ≥ 90).
   - Outputs: JSON for APIs, PDF visualizations (charts/tables).
7. **Stripe Monetization:**
   - Base: USD, support GBP, AUD, CAD, NZD.
   - Monthly/annual plans, webhooks (checkout.session.completed, invoice.payment_failed, customer.subscription.updated).
   - Auto-invoices/receipts, admin view for active customers.
8. **Deployment & Maintenance:**
   - Health check (/status), error logging (print-based for Replit), DB backups (file-based).
   - API versioning (/api/v1/...).
   - Postman collection for all endpoints.
   - Deployment notes for Render/Vercel.

**Project Structure:**
- **Root Directory:** main.py, requirements.txt, .env, setup_guide.md, postman_collection.json
- **Folders:**
  - templates/ (HTML for emails, basic frontend)
  - static/ (css/, js/, reports/ for PDFs)
  - migrations/ (SQL scripts for DB schema)
  - scripts/ (data processing, backup scripts)

**Specific Instructions:**
- All code must be runnable in Replit’s standard environment.
- Provide separate code blocks for each file (main.py, requirements.txt, .env example, sample HTML/CSS/JS, SQL schema, Postman JSON).
- Include comments explaining logic.
- Use only specified libraries: flask, flask-jwt-extended, pandas, gspread, stripe, python-dotenv, reportlab, smtplib/SendGrid.
- Frontend: Provide minimal HTML/CSS/JS for CSV upload/mapping UI, assume React frontend by client.
- Include setup_guide.md with env setup, deployment steps (Render/Vercel), and API usage.
- Postman collection must cover all endpoints (auth, reports, insights, etc.).
- Ensure UI is simple, clean, responsive (Tailwind CSS).
- Mock external integrations (Google Sheets, Stripe) with dummy data if needed for Replit.
- Budget: 700 AUD, timeline: 3-4 weeks.
```

---

**Sample Implementation Outline**

Below is a simplified implementation to demonstrate how the prompt translates into code for Replit. Due to the complexity, I’ll provide key files for the core functionality (auth, reports, ingestion, insights) and a structure for others, keeping it concise per your preference. For a full implementation, the prompt above can be used with a code-focused LLM or developer.

### 1. main.py (Flask Backend)
```python
from flask import Flask, request, jsonify
from flask_jwt_extended import JWTManager, jwt_required, create_access_token, create_refresh_token, get_jwt_identity
import sqlite3
import pandas as pd
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
import smtplib
import os
from dotenv import load_dotenv

app = Flask(__name__)
load_dotenv()
app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET_KEY', 'your-secret-key')
jwt = JWTManager(app)

# SQLite DB setup
def init_db():
    with sqlite3.connect('verocta.db') as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS users
                        (id INTEGER PRIMARY KEY, email TEXT UNIQUE, password TEXT, role TEXT)''')
        conn.execute('''CREATE TABLE IF NOT EXISTS reports
                        (id INTEGER PRIMARY KEY, user_id INTEGER, title TEXT, created_at TEXT)''')

# Auth: Signup
@app.route('/api/signup', methods=['POST'])
def signup():
    data = request.get_json()
    email, password = data.get('email'), data.get('password')
    with sqlite3.connect('verocta.db') as conn:
        try:
            conn.execute('INSERT INTO users (email, password, role) VALUES (?, ?, ?)',
                        (email, password, 'user'))  # Use bcrypt in production
            conn.commit()
            return jsonify({'message': 'User created'}), 201
        except sqlite3.IntegrityError:
            return jsonify({'error': 'Email exists'}), 400

# Auth: Login
@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    email, password = data.get('email'), data.get('password')
    with sqlite3.connect('verocta.db') as conn:
        user = conn.execute('SELECT * FROM users WHERE email = ? AND password = ?',
                           (email, password)).fetchone()
    if user:
        access_token = create_access_token(identity=email)
        refresh_token = create_refresh_token(identity=email)
        return jsonify({'access_token': access_token, 'refresh_token': refresh_token}), 200
    return jsonify({'error': 'Invalid credentials'}), 401

# Reports: List
@app.route('/api/reports', methods=['GET'])
@jwt_required()
def list_reports():
    user_email = get_jwt_identity()
    with sqlite3.connect('verocta.db') as conn:
        reports = conn.execute('SELECT * FROM reports WHERE user_id = ?',
                             (conn.execute('SELECT id FROM users WHERE email = ?', (user_email,)).fetchone()[0],)).fetchall()
    return jsonify([{'id': r[0], 'title': r[2], 'created_at': r[3]} for r in reports])

# Data Ingestion: CSV Upload
@app.route('/api/upload', methods=['POST'])
@jwt_required()
def upload_csv():
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400
    file = request.files['file']
    if not file.filename.endswith('.csv'):
        return jsonify({'error': 'CSV required'}), 400
    df = pd.read_csv(file)
    # Mock column mapping (assume Date, Amount, Category)
    return jsonify({'message': 'CSV processed', 'columns': df.columns.tolist()}), 200

# Insights: SpendScore (simplified)
@app.route('/api/insights', methods=['POST'])
@jwt_required()
def insights():
    data = request.get_json()
    df = pd.DataFrame(data['data'])
    spend_score = min(100, int(df['Amount'].mean() / 100))  # Simplified mock
    return jsonify({'SpendScore': spend_score, 'waste_percent': 10, 'duplicates': 0})

# Health Check
@app.route('/status', methods=['GET'])
def status():
    return jsonify({'status': 'OK'}), 200

if __name__ == '__main__':
    init_db()
    app.run(host='0.0.0.0', port=8080)
```

### 2. requirements.txt
```
flask==2.2.5
flask-jwt-extended==4.5.0
pandas==2.0.3
gspread==5.12.0
stripe==7.0.0
python-dotenv==1.0.0
reportlab==4.0.4
```

### 3. .env (Example)
```
JWT_SECRET_KEY=your-secret-key
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password
```

### 4. templates/upload.html (Minimal Frontend)
```html
<!DOCTYPE html>
<html>
<head>
    <title>Verocta - CSV Upload</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
</head>
<body class="bg-gray-100 p-4">
    <h1 class="text-2xl font-bold">Upload CSV</h1>
    <form action="/api/upload" method="POST" enctype="multipart/form-data">
        <input type="file" name="file" accept=".csv" class="my-2">
        <button type="submit" class="bg-blue-500 text-white p-2 rounded">Upload</button>
    </form>
</body>
</html>
```

### 5. migrations/schema.sql
```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role TEXT NOT NULL
);
CREATE TABLE reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    created_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### 6. setup_guide.md
```markdown
# Verocta Setup Guide

## Environment Setup
1. Install dependencies: `pip install -r requirements.txt`
2. Create `.env` with JWT_SECRET_KEY, SMTP credentials.
3. Initialize DB: Run `migrations/schema.sql` in SQLite.

## Running Locally
- Run `python main.py` in Replit.
- Access at `http://0.0.0.0:8080`.

## Deployment (Render)
1. Push code to GitHub.
2. Create Render app, link repo.
3. Set environment variables in Render dashboard.
4. Configure Gunicorn: `gunicorn -w 4 main:app`.

## API Usage
- Use Postman collection (postman_collection.json).
- Auth: POST /api/signup, POST /api/login.
- Reports: GET /api/reports, GET /api/reports/{id}.
- Upload: POST /api/upload (multipart/form-data).

## Notes
- Mock Google Sheets/Stripe in Replit (use dummy data).
- Scale to PostgreSQL for production.
```

### 7. postman_collection.json (Partial Example)
```json
{
    "info": {
        "name": "Verocta API",
        "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
    },
    "item": [
        {
            "name": "Signup",
            "request": {
                "method": "POST",
                "url": "{{base_url}}/api/signup",
                "body": {
                    "mode": "raw",
                    "raw": "{\"email\": \"test@example.com\", \"password\": \"test123\"}",
                    "options": { "raw": { "language": "json" } }
                }
            }
        },
        {
            "name": "Login",
            "request": {
                "method": "POST",
                "url": "{{base_url}}/api/login",
                "body": {
                    "mode": "raw",
                    "raw": "{\"email\": \"test@example.com\", \"password\": \"test123\"}",
                    "options": { "raw": { "language": "json" } }
                }
            }
        }
    ]
}
```

**Notes:**
- This is a simplified implementation for Replit. Full features (Google Sheets, Stripe, emails, advanced insights) require external API keys and production setup (Render/PostgreSQL).
- Use the prompt with a code-focused LLM or developer to expand features like forecasting, gamification, and PDF generation.
- Deployment notes and Postman collection ensure smooth frontend integration.
- Budget (700 AUD) and timeline (3-4 weeks) are feasible with focused execution.

Proceed with this structure or need specific feature expansion?